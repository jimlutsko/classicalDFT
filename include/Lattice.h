#ifndef __LUTSKO__LATTICE__
#define __LUTSKO__LATTICE__

#include <boost/archive/text_iarchive.hpp>
#include <boost/archive/text_oarchive.hpp>
#include <boost/archive/binary_iarchive.hpp>
#include <boost/archive/binary_oarchive.hpp>
#include <boost/serialization/version.hpp>

/**
  *  @brief This class encapsulates all information relating to the lattice: the number of points, the lattice spaceing and the length of the cell in each direction. Allowance is made for different spacings in each direction but current implementations force all spacings to be equal.
  */  

class Lattice
{
 public:
  /**
  *   @brief  Default  constructor for Lattice
  *  
  *   @param  dx is lattice spacing: assumed to be the same in all directions
  *   @param  L[] are the dimensions of the physical region
  *   @return nothing 
  */  

  Lattice(double dx, double L[])
    : Nx_(0), Ny_(0), Nz_(0), dx_(dx), dy_(dx), dz_(dx)
  { init(L);}

  Lattice(double dx, double dy, double dz, double L[])
    : Nx_(0), Ny_(0), Nz_(0), dx_(dx), dy_(dy), dz_(dz)
  { init(L);}  
  
  Lattice()
  {
    Nx_ = Ny_ = Nz_ = 0;
    Ntot_ = Nout_ = 0;
    dx_ = dy_ = dz_ = 0;
    L_[0] =  L_[1] = L_[2] = 0;
  }

  Lattice(const Lattice& ref) {copy(ref);}

  Lattice& operator=(const Lattice &a){copy(a);return *this;}

  void     set_boundary_width(unsigned b) { boundary_width_ = b;}
  unsigned get_boundary_width()           { return boundary_width_;}
  
  void copy(const Lattice &ref)     
  {
      Nx_ = ref.Nx_;
      Ny_ = ref.Ny_;
      Nz_ = ref.Nz_;

      Ntot_ = ref.Ntot_;
      Nout_ = ref.Nout_;

      dx_ = ref.dx_;
      dy_ = ref.dy_;
      dz_ = ref.dz_;

      L_[0] = ref.L_[0];
      L_[1] = ref.L_[1];
      L_[2] = ref.L_[2];

      boundary_width_ = ref.boundary_width_;
  }


void init(double L[])
  {	
    L_[0] =L[0];
    L_[1] =L[1];
    L_[2] =L[2];

    Nx_ = long((L[0]+1e-8*dx_)/dx_);
    Ny_ = long((L[1]+1e-8*dy_)/dy_);
    Nz_ = long((L[2]+1e-8*dz_)/dz_);

    L_[0] = (Nx_-0)*dx_;
    L_[1] = (Ny_-0)*dy_;
    L_[2] = (Nz_-0)*dz_;


    if(fabs(L[0]-Nx_*dx_) > 1e-5*dx_)
      {
	cout << "L[0] = " << L[0] << " L_[0] = " << L_[0] << " Nx*dx = " << Nx_*dx_ << endl;
	throw std::runtime_error("Box length incommensurate with lattice in x direction");
      }
    if(fabs(L[1]-Ny_*dy_) > 1e-5*dy_)
      throw std::runtime_error("Box length incommensurate with lattice in y direction");

    if(fabs(L[2]-Nz_*dz_) > 1e-5*dz_)
      throw std::runtime_error("Box length incommensurate with lattice in z direction");

    Ntot_ = Nx_*Ny_*Nz_;
    Nout_ = Nx_*Ny_*((Nz_/2)+1);
  }
  
  // accessors
  double getDX() const {return dx_;}
  double getDY() const {return dy_;}
  double getDZ() const {return dz_;}
  long Nx() const { return Nx_;}
  long Ny() const { return Ny_;}
  long Nz() const { return Nz_;}
  long get_dimension(int direction) const
  {
    if(direction == 0) return Nx_;
    if(direction == 1) return Ny_;
    if(direction == 2) return Nz_;

    throw std::runtime_error("direction out of bounds in Lattice::get_dimension()");
  }
  double Lx() const { return L_[0];}
  double Ly() const { return L_[1];}
  double Lz() const { return L_[2];}
  long Ntot() const { return Ntot_;}

  long size() const { return Ntot_;}
  long Nout() const { return Nout_;}
  double dV() const { return dx_*dy_*dz_;}
  double getVolume() const { return get_volume();}
  double get_volume() const { return L_[0]*L_[1]*L_[2];}
  
  // Translate index to cartesian coordinates
  double getX(int i) const { return dx_*(i-double(Nx_)/2);}
  double getY(int i) const { return dy_*(i-double(Ny_)/2);}
  double getZ(int i) const { return dz_*(i-double(Nz_)/2);}

  double getX(double i) const { return dx_*(i-double(Nx_)/2);}
  double getY(double i) const { return dy_*(i-double(Ny_)/2);}
  double getZ(double i) const { return dz_*(i-double(Nz_)/2);}

  // Cartesian indices into vector index
  inline long pos(int v[]) const { return pos(v[0],v[1],v[2]);}
  inline long pos(int i, int j, int k) const
  {
    if(i < 0 || i >= Nx_) throw std::runtime_error("ix out of bounds");
    if(j < 0 || j >= Ny_) throw std::runtime_error("iy out of bounds");
    if(k < 0 || k >= Nz_) throw std::runtime_error("iz out of bounds");
    return k + Nz_*(j +  Ny_*i);
  }
  // this is for complex arrays generated by FFTW3
  inline long kpos(int i, int j, int k) const
  {
    if(i < 0 || i >= Nx_) throw std::runtime_error("ix out of bounds");
    if(j < 0 || j >= Ny_) throw std::runtime_error("iy out of bounds");
    if(k < 0 || k >= 1+(Nz_/2)) throw std::runtime_error("iz out of bounds");
    return k + (1 + (Nz_/2))*(j +  Ny_*i);
  }  
  
  // Vector index to Cartesian indices
  inline void cartesian(long pos, int v[]) const
  {
    int ix,iy,iz; cartesian(pos,ix,iy,iz);
    v[0] = ix; v[1] = iy; v[2] = iz;
  }
  
  inline void cartesian(long pos, int &i, int &j, int &k) const { k = pos%(Nz_); pos = (pos-k)/Nz_; j = pos%Ny_; i = pos/Ny_;}  

  // Get vector index taking account of PBC
  virtual long get_PBC_Pos(int v[]) const {return get_PBC_Pos(v[0],v[1],v[2]);}  
  virtual long get_PBC_Pos(int ix, int iy, int iz) const
  { 
    putIntoBox(ix,iy,iz);
    return pos(ix,iy,iz);
  }

  // Apply PBC to cartesian indices
  void putIntoBox(int &ix, int &iy, int &iz) const
  {
    while(ix < 0)  ix += Nx_; 
    while(ix >= Nx_) ix -= Nx_;
    
    while(iy < 0)  iy += Ny_; 
    while(iy >= Ny_) iy -= Ny_;
    
    while(iz < 0)  iz += Nz_; 
    while(iz >= Nz_) iz -= Nz_; 
  }

  friend ostream &operator<<(ostream &of, const Lattice &l) 
  {    
    of.write((char*) &l.Nx_, sizeof(long));
    of.write((char*) &l.Ny_, sizeof(long));
    of.write((char*) &l.Nz_, sizeof(long));

    of.write((char*) &l.Ntot_, sizeof(long));
    of.write((char*) &l.Nout_, sizeof(long));    

    of.write((char*) &l.dx_, sizeof(double));
    of.write((char*) &l.dy_, sizeof(double));
    of.write((char*) &l.dz_, sizeof(double));

    of.write((char*) &l.L_, 3*sizeof(double));
    
    return of;
  }

  ////////// Characterizing boundary points:
  // Boundary points are those within a distance of b of the edge of the cell.
  // We map points on the boundary (ix <= b or ix >= Nx-b;  or iy <= b or iy >= Ny-b or iz <= b or iz >= Nz - b )
  // to an array of k(NyNz+ (Nx-k)Nz+(Nx-k)(Ny-k)) points where k = 1+2b
  // or, equivalently,  k(NxNy + NxNy + NyNz -k(Nx+Ny+Nz) +k*k) points.


  bool is_boundary_point(long pos) const
  {
    int ix, iy, iz;
    cartesian(pos,ix,iy,iz);

    unsigned b = boundary_width_;
    
    return ((ix%Nx_ <= b || ix%Nx_ >= Nx_-b) || (iy%Ny_ <= b || iy%Ny_ >= Ny_-b) || (iz%Nz_ <= b || iz%Nz_ >= Nz_-b));
  }
  
  long get_Nboundary() const { int k = 1+2*boundary_width_; return k*(Nx_*Ny_+Nx_*Nz_+Ny_*Nz_-k*(Nx_+Ny_+Nz_)+k*k);}
  // cartesian coordinates to position
  long boundary_pos(int v[]) const { return boundary_pos(v[0],v[1],v[2]);}

  long boundary_pos(int ix, int iy, int iz) const    
  {
    long pos = -1;
    // First get points in cell
    while(ix < 0) ix += Nx_;
    while(iy < 0) iy += Ny_;
    while(iz < 0) iz += Nz_;

    while(ix > Nx_-1) ix -= Nx_;
    while(iy > Ny_-1) iy -= Ny_;
    while(iz > Nz_-1) iz -= Nz_;

    unsigned b = boundary_width_;
    unsigned k = 1+2*b;
    
    if(iz <= b)
      pos = iz*Nx_*Ny_ + ix*Ny_+iy;
    else if(iz >= Nz_-b)
      pos = (b+1)*Nx_*Ny_ + (iz-(Nz_-b))*Nx_*Ny_  + ix*Ny_+iy;
    else if(iy <= b)
      pos = k*Nx_*Ny_ + (iy*Nx_ + ix)*(Nz_-k)+iz-1-b;
    else if(iy >= Ny_-b)
      pos = k*Nx_*Ny_ + (b+1)*Nx_*(Nz_-k) + ((iy-(Ny_-b))*Nx_ + ix)*(Nz_-k)+iz-1-b;
    else if(ix <= b)
      pos = k*Nx_*Ny_ + k*Nx_*(Nz_-k) + (ix*(Ny_-k)+(iy-b-1))*(Nz_-k)+(iz-b-1);
    else if(ix >= Nx_-b)
      pos = k*Nx_*Ny_ + k*Nx_*(Nz_-k) + (b+1)*(Ny_-k)*(Nz_-k) + ((ix-(Nx_-b))*(Ny_-k)+(iy-b-1))*(Nz_-k)+(iz-b-1);
    else 
      throw std::runtime_error("Non-boundary point given to Lattice::boundary_pos");
 
    return pos;
  }

  long boundary_pos_2_pos(long p) const
  {
    int ix,iy,iz;
    boundary_cartesian(p,ix,iy,iz);
    return pos(ix,iy,iz);
  }

  void boundary_cartesian(long pos,int v[]) const
  {
    int ix,iy,iz;
    boundary_cartesian(pos,ix,iy,iz);
    v[0] = ix; v[1] = iy; v[2] = iz;
  }
  
  void boundary_cartesian(long pos,int &ix, int &iy, int &iz) const
  {
    ix = iy = iz = 0;

    unsigned b = boundary_width_;
    unsigned k = 1+2*b;

    if(pos < (b+1)*Nx_*Ny_)
      {
	//pos = iz*Nx_*Ny_ + ix*Ny_+iy;	
	iz = pos/(Nx_*Ny_); pos -= iz*Nx_*Ny_;
	ix = pos/Ny_;       pos -= ix*Ny_;
	iy = pos;
      } else if(pos < k*Nx_*Ny_) {
      //pos = (iz+k-Nz_)*Nx_*Ny_  + ix*Ny_+iy;
	iz = Nz_-k+pos/(Nx_*Ny_); pos -= (iz-(Nz_-k))*Nx_*Ny_;
	ix = pos/Ny_; pos -= ix*Ny_;
	iy = pos;
    } else if(pos < k*Nx_*Ny_ + (b+1)*Nx_*(Nz_-k)) {
      //pos = k*Nx_*Ny_ + (iy*Nx_ + ix)*(Nz_-k)+iz-1-b;
      iy = (pos-k*Nx_*Ny_)/(Nx_*(Nz_-k)); pos -= k*Nx_*Ny_ + iy*Nx_*(Nz_-k);
      ix = pos/(Nz_-k); pos -= ix*(Nz_-k);
      iz = pos+1+b;
    } else if(pos < k*Nx_*Ny_ + k*Nx_*(Nz_-k)) {
      //pos = k*Nx_*Ny_ + (b+1)*Nx_*(Nz_-k) + ((iy-(Ny_-b))*Nx_ + ix)*(Nz_-k)+iz-1-b;      
      iy = Ny_-b + (pos - k*Nx_*Ny_ - (b+1)*Nx_*(Nz_-k))/(Nx_*(Nz_-k)); pos -= k*Nx_*Ny_ + (b+1)*Nx_*(Nz_-k) + (iy-(Ny_-b))*Nx_*(Nz_-k);
      ix = pos/(Nz_-k); pos -= ix*(Nz_-k);
      iz = pos+1+b;
    } else if(pos < k*Nx_*Ny_ + k*Nx_*(Nz_-k) + k*(Ny_-k)*(Nz_-k) ) {
      //pos = k*Nx_*Ny_ + k*Nx_*(Nz_-k) + (ix*(Ny_-k)+(iy-b-1))*(Nz_-k)+(iz-b-1);
      ix = (pos - k*Nx_*Ny_ - k*Nx_*(Nz_-k))/((Ny_-k)*(Nz_-k)); pos -= k*Nx_*Ny_ + k*Nx_*(Nz_-k) + ix*(Ny_-k)*(Nz_-k);
      iy = 1+b+pos/(Nz_-k); pos -= (iy-b-1)*(Nz_-k);
      iz = pos+1+b;
    } else
      throw std::runtime_error("Non-boundary point given to Lattice::boundary_cartesian");      
  }


  // Loop over boundary points. The order is (with k = 2b+1)
  // x-boundary k*Ny*Nz points
  // y-boundary k*(Nx-k)*Nz points
  // z-boundary k*(Nx-k)*(Ny-k) points
  // giving a total of k*(Ny*Nz + Nx*Nz + Nx*Ny - k*Nz - k*Ny-k*Nx+k*k) points
  // as expected.
  bool get_next_boundary_point(int &ix, int &iy, int &iz) const
  {
    int b = boundary_width_;
    long pos_input = pos(ix,iy,iz);
    
    // are we in x-boundary ?
    if(ix <= b || ix >= Nx_-b)
      {
	if(iz < Nz_-1)     {iz++; return true;} 	
	if(iy < Ny_-1)     {iy++; iz = 0; return true;}
	if(ix < b)         {ix++;       iy=iz=0; return true;}
	if(ix == b && b>0) {ix = Nx_-b; iy=iz=0; return true;}
	if(ix > b && ix < Nx_-1)     {ix++;       iy=iz=0; return true;}
	ix = b+1; iy=iz=0; return true; // go to y boundary
      }

    // are we in y-boundary?
    // We cannot visit x-boundary points
    if(iy <= b || iy >= Ny_-b)
      {
	if(iz < Nz_-1)     {iz++; return true;} 	
	if(ix < Nx_-b-1)   {ix++; iz = 0; return true;}
	if(iy < b)         {iy++;    ix = b+1; iz = 0; return true;}
	if(iy == b && b>0) {iy=Ny_-b;ix = b+1; iz = 0; return true;}
	if(iy > b && iy < Ny_-1)     {iy++;    ix = b+1; iz = 0; return true;}
	ix = iy = b+1; iz = 0; return true; // go to z-boundary
      }
    // are we on z-boundary?
    // we cannot visit x or y boundary points
    if(iz <= b || iz >=Nz_-b)
      {
	if(iy < Ny_-b-1)   {iy++; return true;}
	if(ix < Nx_-b-1)   {ix++; iy = b+1; return true;}
	if(iz < b)         {iz++;    ix = b+1; iy = b+1; return true;}
	if(iz == b && b>0) {iz=Nz_-b;ix = b+1; iy = b+1; return true;}
	if(iz > b && iz < Nz_-1) {iz++;    ix = b+1; iy = b+1; return true;}
      }
    // no where left to go or we were fed a bad starting point
    if (!is_boundary_point(pos_input))
      throw std::runtime_error("Lattice::get_next_boundary_point called with bad arguments");
    else return false;
  }

  bool get_next_boundary_point(long &p) const
  {
    int ix,iy,iz;
    cartesian(p,ix,iy,iz);
    bool ret = get_next_boundary_point(ix,iy,iz);
    if(ret) p = pos(ix,iy,iz);
    return ret;
  }


  // a function for testing the boundary stuff
  void test_boundary_coding();

  friend istream &operator>>(istream  &in, Lattice &l )     
  {
    in.read((char*) &l.Nx_, sizeof(long));
    in.read((char*) &l.Ny_, sizeof(long));
    in.read((char*) &l.Nz_, sizeof(long));
    
    in.read((char*) &l.Ntot_, sizeof(long));
    in.read((char*) &l.Nout_, sizeof(long));    
    
    in.read((char*) &l.dx_, sizeof(double));
    in.read((char*) &l.dy_, sizeof(double));
    in.read((char*) &l.dz_, sizeof(double));
    
    in.read((char*) &l.L_, 3*sizeof(double));

    in.read((char*) &l.boundary_width_, sizeof(unsigned));
    
    return in;
  }    
  friend class boost::serialization::access;
  template<class Archive> void serialize(Archive & ar, const unsigned int version)
  {
    ar & Nx_;
    ar & Ny_;
    ar & Nz_;

    ar & Ntot_;
    ar & Nout_;

    ar & dx_;
    ar & dy_;
    ar & dz_;

    ar & L_;
    if(version > 0)
      ar & boundary_width_;
  }
  
protected:
  long Nx_; ///< Number of lattice points in x direction
  long Ny_; ///< Number of lattice points in y direction
  long Nz_; ///< Number of lattice points in z direction

  long Ntot_;  ///< Total number of lattice points
  long Nout_;  ///< Total number of lattice points in fourier space (a la fftw)

  double dx_;   ///< Lattice spacing in x direction
  double dy_;   ///< Lattice spacing in y direction
  double dz_;   ///< Lattice spacing in z direction

  double L_[3];    ///< Dimensions of physical box in hard-sphere units

  unsigned boundary_width_ = 0;
};

BOOST_CLASS_VERSION(Lattice, 1)

#endif
